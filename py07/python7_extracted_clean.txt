DataDec k
Master the Art of Abstract Card Arc hitecture
Summary: W elc ome to DataDe ck - the ultimate c ar d game engine! Master Python 's
abstr act classes and interfac es by building a mo dular tr ading c ar d system. L e arn to
cr e ate exible, extensible game ar chite ctur es thr ough pr o gr essive chal lenges c overing
abstr act b ase classes, multiple inheritanc e, and interfac e c omp osition.
Con ten ts
I F orew ord
I I AI Instructions
I I I In tro duction
IV Common Instructions
IV.1 General R ules
IV.2 A uthoriz ed Imp orts
IV.3 F orbidden
IV.4 Pro ject Structure
IV.5 Help er T o ols
IV.6 The DataDec k Arc hitecture
V Exercise 0: Card F oundation
VI Exercise 1: Dec k Builder
VI I Exercise 2: Abilit y System
VI I I Exercise 3: Game Engine
IX Exercise 4: T ourna me n t Platform
X Submission
Chapter I
F orew ord
W elcome, aspiring Dec k Arc hitect, to the w orld of DataDec k!
Picture this: Y ou're designing the next legendary trading card game. Think Magic: The
Gathering meets Hearthstone meets P ok mon - but with a t wist! Y our cards aren't just
static images; they're dynamic data en tities that can ev olv e, com bine, and in teract in
coun tless w a ys. But here's the c hallenge: Ho w do y ou create a system exible enough to
handle thousands of dieren t card t yp es while main taining clean, main tainable co de?
The secret lies in
Abs tra ct Programming P atterns
! Just lik e ho w ev ery trading card
game has fundamen tal car d t yp es (Creatures, Sp ells, Artifacts), y our co de ne eds founda-
tional blueprin ts that dene ho w ALL ca rds b eha v e.
abstract base classes
as the legendary card templates of programming.
Whether y ou're creating a Fire Dragon, Ligh tning Bolt, or He aling P otion, they all fol-
lo w the same cor e pattern:
cost, eect, activ ation, resolution
. Y our abstract classes
ensure ev ery card in y our dec k follo ws these univ ersal rules!
In terfaces
are lik e the sp ecial abilities that cards can ha v e. A card migh t b e
(can b ypass ground defenses),
Stac kable
(eects can com bine), or
T radeable
exc hanged b et w een pla y ers). Python's ABC mo dule lets y ou mix and matc h these abili-
ties lik e building the p erfect dec k!
In this activit y , y ou'll build "DataDec k" - a mo dular card game engine that c ould p o w er
the next generat ion of digital tr ading card games. Y ou'll disco v er ho w abstract patterns
mak e complex game systems manageable, extensible, and fun to dev elop. By the end,
y ou'll think lik e a senior game arc hitect, designing systems that can ev olv e with new card
sets and mec hanics!
Chapter I I
AI Instructions
During y our learning journey , AI can assist with man y dieren t tasks. T ak e the time to
explore the v arious capabilitie s of AI to ols and ho w they can supp ort y our w ork. Ho w-
ev er, alw a ys approac h them w ith caution and critically assess the results. Whether it's
co de, do cumen tation, ideas, or tec hnical explanations, y ou can nev er b e completely sure
that y our question w as w ell-formed or that the generated con ten t is accur ate. Y our p eers
are a v aluable resour ce to help y ou a v oid mistak es and blind sp ots.
Main message
Use AI to reduce rep etitiv e or tedious tasks.
Dev elop prompting skills b oth co ding and non-co ding that will b enet y our
future career.
Lear n ho w AI systems w ork to b etter an ticipate and a v oid common risks, biases,
and ethical issues.
Con tin ue building b oth tec hnical and p o w er skills b y w orking with y our p eers.
Only use AI-gene rated con ten t that y ou fu lly understand and can tak e resp onsibilit y
Learner rules:
Y ou should tak e the time to explore AI to ols and unde rstand ho w they w ork, so
y ou can use them ethically and reduce p oten tial biases.
Y ou should r eect on y our problem b efore prompting this helps y ou write c learer,
more detailed, and more relev an t prompts using acc urate v o cabulary .
Y ou should dev elop t he habit of systematically c hec king, reviewing, questioning,
and testing an ything generated b y AI.
Y ou should alw a ys seek p eer review don't rely solely on y our o wn v alidation.
DataDec k Master the Art of Abstract Card Arc hitecture
Phase outcomes:
Dev elop b oth general-purp ose and domain-sp ecic prompting skills.
Bo ost y our pro ductivit y w ith eectiv e use of AI to ols.
Con tin ue strengthening computational thinking, problem-solving, adaptabilit y , and
collab oration.
Commen ts and examples:
Y ou'll regularly encoun ter situations exams, ev aluations, and more where
y ou m ust demonstrate re al understanding. Be prepa red, k eep building b oth y our
tec hnical and in terp ersonal skills.
Explaining y our reasoning and debating with p eers often rev eals gaps in y our un-
derstanding. Mak e p eer learning a priorit y .
AI to ols often lac k y our sp ecic con text and tend to pro vide generic resp onses. Y our
p eers, w ho share y our en vironmen t, can oer more relev a n t and accurate insigh ts.
Where AI te nds to g enerate the most lik ely answ er, y our p e ers can pro vide alter-
nativ e p ersp ectiv es a nd v aluable n uanc e. Rely on them as a qualit y c hec kp oin t.
Go o d practice:
I ask AI: Ho w do I test a sorting function? It giv es me a few ideas. I try them out
and review the results with a p eer. W e rene the approac h togethe r.
Bad practice:
I ask AI to write a whole fun ction, co p y-paste it in to m y pro ject. During p eer -
ev aluat ion, I can't explain what it do es or wh y . I lose credibilit y and I fail m y
I use AI to help design a parser. Then I w alk through the logic with a p eer. W e catc h
t w o bugs and rewrite it together b etter, cleaner, and fully understo o d.
I let Copilot generate m y co de for a k ey part of m y pro ject. It compiles, but I can't
explain ho w it handles pip es. During the ev aluatio n, I fail to justify and I fail m y
Chapter IV
Common Instructions
Y our pro j ect m ust b e w ritten in
Python 3.10 or later
Y our pro j ect m ust adhere to the
co ding standard.
Y our functions should handle exceptions grac efully to a v oid crashes.
t yp e hin ts
for all function signatures a nd class metho ds.
F o cus on demonstrating abstract programming patterns clearly .
All card pro cessing should b e done in-memory (no le I/O required).
IV.2 A uthorized Imp orts
mo dule (Abstract Base Classes) - Essen tial for this pro ject
mo dule - F or adv anced t yp e hin ts
mo dule - F or card sh uing and eects
mo dule - F or card t yp es and rarities
datetime
mo dule - F or game timestamps
Standard library mo dules as needed
External libraries (no pip install)
File I/O op e rations (fo cus on in-memory pro cessing)
Complex game logic ( k eep card eects simple)
Using ev al() or exec()
IMPOR T ANT - Rep ository Structure:
Y our Git rep ository m ust ha v e the follo wing
structure:
Rep ository structure:
your-repo/
|- __init__.py (REQUIR ED)
| |- __init__.py ( REQUIRED)
| |- CreatureCard.py
- main.py (REQU IRED)
|- __init__.py (REQUIRED)
le at the rep ository ro ot is
MAND A TOR Y
for Python to recognize
y our exercises as pac ka ges and enable absolute imp orts.
Execution:
All exercises must be executed from the repository root
using: python3 -m exN.main (where N is the exercise number).
Example: python3 -m ex0.main
Use absolute imports between exercises:
from ex0.Card import Card
from ex1.SpellCard import SpellCard
use relative imports like from ..ex0.Card import Card
Card Generator Available (Optional):
A card generator utility is
provided in the project attachments (card_generator.tar.gz) to help
you during development. This is
NOT required for submission
just a helper tool.
If y ou w an t to use it, ex tract it in y our rep ository:
$ tar -xzf card_generator.tar. gz
$ mkdir -p tools
$ mv card_generator.py tools/
$ touch tools/__init__.p y
Y ou can then use it to generate sample cards for testing y our implemen tations. Imp ort
from tools.ca rd_generator import CardGenerator
directory is for dev elo pmen t only and should NOT b e included in
y our Git submission.
Decorators Policy:
While @abstractmethod decorators are commonly
used with abstract classes, they are
optional
for this activity. You
can implement abstract classes using the abc module with or without
decorators - both approaches are acceptable and will be evaluated
In this activit y , y ou'll build a mo dular card game engine. Eac h exercise represen ts a k ey
arc hitectural comp onen t:
F oundation La y er
: Abstra ct base classes t hat dene card con tracts
Implemen tation La y er
: Concrete card t yp es with sp ecic b eha viors
Abilit y La y er
: In terfaces for sp ecial card abilities
Engine La y er
: Game mec hanics and card in teraction s yste ms
Platform La y er
: A dv anced comp osition a nd tournamen t managemen t
Think of this as building the "engine" of a trading card game - each
layer adds functionality and intelligence to create engaging card
interactions.
Chapter V
Exercise 0: Card F oundation
Exercise0
Directory:
Files to Submit:
__init__.py, Card.py, CreatureCard.py, main.py
A uthorized:
abc, typing, enum, print()
F oundation La y er: Building the Univ ersal Card Blueprin t
In trading card games, thousands of dieren t c ards exist - creatures, sp ells, artifacts, and
more. But ho w do y ou ensure all these dieren t card t yp es can w ork t ogether in the same
game? The answ er:
Your Mission
: Create the foundational blueprint that defines how ALL
cards in DataDeck must behave. This is like creating the "universal
card template" that ensures any card can be played in your game
Implemen tation
- P ac kage initialization le
- The abstra ct foundation class
Creatur eCard.py
- Y o ur rst concrete card t yp e
- Demonstration sc ript (required for all exercises)
T ec hnical Requiremen ts
Class Signatures:
# Card (Abstract Base Class)
def __init__(self , name: str, cost: int, rarity: str)
def play(self, game_stat e: dic t) -> dict
def get_card_info (self) -> dic t
def is_playable(s elf, av ailable_mana: int) -> bool
# CreatureCard (Concrete Imple mentation)
def __init__(self , name: str, cost: int, rarity: str, attack : int, healt h: int )
def attack_target (self, target) -> d ict
- Cr eate an abstract base class with:
Inherit from
(Abstract Base Class)
Construc tor:
__init __(self, name: str, cos t: int, rarity: str)
Abstract metho d:
play(self, game_s tate: dict)
Concr ete metho d:
get_card_info(self)
is_playable(self, available_mana: int)
CreatureCard.p y
- Cre ate a concrete implemen tation that:
Inherits from
A dds attac k and health at tributes
Implemen ts the abstract
attack_target
metho d for creature com bat
V alidates that attac k and health are p ositiv e in tegers
Exp ected Output Example:
$> python3 -m ex0.main
=== DataDeck Card Foundation ===
Testing Abstract Base Class Design:
CreatureCar d Info :
Fire Dragon
Le gendary
Creature
Playing Fire Dragon with 6 mana available:
Playable: True
Play result: {
card_play ed
Fire D ragon
mana_used
Creatur e summ oned t o batt lefield
Fire Dragon attacks Goblin Warrior:
Attack result: {
attacke r
F ire Dr agon
Goblin Warrior
damage_dea lt
comb at_resolved
Testing insufficie nt man a (3 availab le):
Playable: False
Abstract pattern success fully demonstrated!
ensure consistency across different
card types? What happens if you try to create a Card directly
without implementing required methods?
Chapter VI
Exercise 1: Dec k Builder
Exercise1
Files to Su bmit:
__init__.py, SpellCard.py, ArtifactCard.py, Deck.py, main.py
abc, typing, enum, random, print()
Implemen tation La y er: The Dec k Builder System
Y our card foundation is solid! No w build dieren t card t yp es that can all w ork together
in the same dec k. Create a dec k builder that can manage creatures, sp ells, and artifacts
using the same in terface.
: Build multiple concrete card types that all implement
your abstract interface. Create a deck management system that can
handle any card type using your foundation.
SpellCa rd.py
- Instan t magic eect s
Artifac tCard.py
- P ermanen t game mo diers
- Dec k managemen t system
- Demonstration sc ript
Import your Card from ex0 using: from ex0.Card import Card.
Each exercise must include a main.py file that demonstrates the
functionality.
Important:
Create an __init__.py file in each
exercise directory to make it a Python package.
: Class Signatures:
# SpellCard (Concrete Implemen tation)
def __init__(self , name: str, cost: int, rarity: str, effect _type: str)
def resolve_effec t(self, targets: list) -> dict
# ArtifactCard (Concrete Imple mentation)
def __init__(self , name: str, cost: int, rarity: str, durabi lity: int, e ffect: str)
def activate_abil ity(self) -> dict
# Deck (Management Class)
def add_card(self , card: Card) -> None
def remove_card(s elf, ca rd_name: str) -> b ool
def shuffle(self) -> None
def draw_card(sel f) -> Card
def get_deck_stat s(self) -> di ct
Sp ellCard.p y
Pro cesses instan t magical e ects
Has eect_t yp e attribute (damage, heal, bu, debu )
Implemen ts
resolve_effect
for sp ell mec hanic s
Sp ells are consumed when pla y ed (one-time use)
ArtifactCard.p y
Repre s e n ts p ermanen t game mo diers
Has durabilit y attribute (ho w long it lasts)
Has eect attribute describing the artifact's p ermanen t abilit y
activate_ability
for ongoing e ects
Artifac ts remain in pla y un t il destro y ed
- Dec k manage men t class:
add_card(card: Card)
remove_card(card_name: str)
draw_card()
get_deck_stats()
$> python3 -m ex1.main
=== DataDeck Deck Builder ===
Building deck with different card types...
Deck stats: {
total_card s
crea tures
artifacts
Drawing and playing cards:
Drew: Lightning Bolt (Spell)
Lightning Bolt
Deal 3 damage to target
Drew: Mana Crystal (Artifact)
Mana C rystal
Permane nt: +1 mana per turn
Drew: Fire Dragon (Creature)
Polymorphis m in action: Same interfa ce, di fferent card behaviors!
polymorphism
enable the Deck to work with any card type?
What are the benefits of this design pattern for card game systems?
Chapter VI I
Exercise 2: Abilit y System
Exercise2
__init__.py, Combatable.py, Magical.py, EliteCard.py,
Abilit y La y er: Multiple In terface Design
Card games need exible abilit y systems! T ime to build the Abilit y La y er using m u ltiple
in terfaces that can b e com bined to create p o w erf ul, v ersatile cards with m ultiple sp ecial
abilities.
: Design multiple abstract interfaces that can be
combined using multiple inheritance. Create cards that implement
combat, magic, and utility abilities simultaneously.
Combata ble.py
- Abstract com bat in terface
Magical .py
- Abstract magic in ter face
EliteCa rd.py
- Multiple inhe ritance implemen tation
Import Card from ex0 in your EliteCard.py using: from ex0.Card
import Card. Each exercise must include a main.py file that
demonstrates the functionality.
Create an __init__.py
file in each exercise directory.
# Combatable (Abstract Interfa ce)
def attack(self, target) -> dict
def defend(self, incomin g_damage: int) -> dict
def get_combat_st ats(self) -> dict
# Magical (Abstract Interface)
def cast_spell(se lf, spe ll_name: str, targets: list) -> dict
def channel_mana( self, amount: int) -> dic t
def get_magic_sta ts(self) -> d ict
# EliteCard (Multiple Inherita nce: C ard + Combat able + Magic al)
Com batable.p y
- Abstract com bat in terface:
attack(self, targ et)
defend(self, inco ming_damage: int)
get_combat_stats(self)
Magical.p y
- Abs t ract magic in terface:
cast_spell(self, spell_name: str, targets: list)
channel_mana(self, amount: i nt)
get_magic_stats(self)
EliteCard.p y
- Multiple inheritance class:
Combatable
Implemen ts ALL abstract metho ds from all three in terface s
Repre s e n ts p o w erful cards with m ultiple abilities
Com bines com bat pro w ess with magical capabilities
$> python3 -m ex2.main
=== DataDeck Ability System ===
EliteCard capabili ties:
get_card_inf o
i s_playable
- Combatable: [
get_combat_stats
cast_spell
cha nnel_mana
get_magic_sta ts
Playing Arcane Warrior (Elite Card):
Combat phase:
A rcane Warrior
combat_typ e
Defense result: {
defend er
Arcane Warrior
damage_taken
damage_blo cked
st ill_alive
Magic phase:
Spell cast: {
Arcane Warri or
Fireball
Mana channel: {
channele d
tota l_mana
Multiple interface imple mentation successful!
multiple interfaces
enable flexible card design? What are
the advantages of separating combat and magic concerns?
Import interfaces from previous exercises as needed: from ex0.Card
import Card, from ex1.SpellCard import SpellCard, etc. Each exercise
must include a main.py file that demonstrates the functionality.
Create an __init__.py file in each exercise directory.
# GameStrategy (Abstract Inter face)
def execute_turn( self, hand: l ist, b attlefield: list) -> dict
def get_strategy_ name(self) -> str
def prioritize_ta rgets(self, available_targe ts: li st) -> list
# CardFactory (Abstract Factor y Inte rface)
def create_creatu re(self, name_or_power) -> Card
def create_spell( self, name_or_power) -> Card
def create_artifa ct(self, name_or_power) -> Card
def create_themed _deck(self, size: int) -> dict
def get_supported _types(self) -> dict
# AggressiveStrat egy (Co ncrete Strategy)
# GameEngine (Game Orchestrato r)
def configure_eng ine(self, factory: CardFactory, strateg y: Gam eStrategy) -> None
def simulate_turn (self) -> dic t
def get_engine_st atus(self) -> dict
GameStrategy .p y
- Abstract strategy in terface:
execute_turn(self, hand: lis t, battlefield: list)
get_strategy_name(self)
prioritize_targets(self, available_targets: list)
CardF actory .p y
- Abstract factory in terface:
create_creature(self, name_or_power)
create_spell(self, name_or_power)
create_artifact(self, name_or_power)
create_themed_deck(self, size: int)
get_supported_types(self)
Aggressiv eStrategy .p y
- Concrete strategy:
Prioritiz es attac king and dealing damag e
Pla ys lo w-c ost creatures rst for b oard presence
T argets enem y creatures and pla y er directly
Returns comprehensiv e turn execution results
F an tasyCardF actory .p y
- Concrete factory:
Crea tes fan tasy-theme d creatures (Dragons, Goblins, etc.)
Crea tes elemen ta l sp ells (Fire, Ice, Ligh tning)
Crea tes magical artifacts (Rings, Stas, Crystals)
Supp orts extensible card t yp e registration
GameEngine.p y
- Game orc hestrator:
configure_engine(factory, strategy)
simulate_turn()
get_engine_status()
$> python3 -m ex3.main
=== DataDeck Game Engine ===
Configuring Fantas y Card Game. ..
Factory: FantasyCa rdFactory
Strategy: Aggressi veStrategy
Available types: {
creat ures
fir eball
ma na_ring
Simulating aggress ive tu rn...
Hand: [Fire Dragon (5), Goblin Warrior (2), Lightning Bolt (3)]
Turn execution:
cards_p layed
targets _attacked
Enemy Player
Game Report:
turns_sim ulated
strategy_used
Aggressiv eStrategy
total_dama ge
card s_created
Abstract Factory + Strategy Pattern: Maxim um fle xibility achieved!
Abstract Factory
Strategy
patterns work together? What
makes this combination powerful for game engine systems?
Chapter IX
Exercise 4: T ournamen t Platform
Exercise4
__init__.py, Rankable.py, TournamentCard.py,
TournamentPlatform.py, main.py
Platform La y er: A dv anced In terface Comp osition
Time to com bine ev erything y ou'v e learned in to a unied tournamen t system that de mon-
strates mastery of abstract programming patterns.
: Create a comprehensive tournament platform that
combines abstract classes, multiple interfaces, and factory
patterns into one cohesive system. Build a platform that can manage
tournaments with different card types and strategies.
Rankabl e.py
- Simple r anking in terfac e
Tournam entCard.py
- Card with tournamen t capabilities
Tournam entPlatform.py
- Platform managemen t system
Import and combine classes from previous exercises: from ex0.Card
import Card, from ex2.Combatable import Combatable, etc. Each
exercise must include a main.py file that demonstrates the
exercise directory.
# Rankable (Abstract Interface )
def calculate_rat ing(self) -> int
def update_wins(s elf, wi ns: in t) -> None
def update_losses (self, losses: int) -> No ne
def get_rank_info (self) -> dic t
# TournamentCard (Multip le Inh eritance: Card + C ombatable + Rankable)
def get_tournamen t_stats(self) -> dict
# TournamentPlatf orm (Pl atform Management)
def register_card (self, card: TournamentCard) -> str
def create_match( self, card1_id: str, card2_id: str) -> dict
def get_leaderboa rd(self) -> l ist
def generate_tour nament_report(self) -> dict
Rankable.p y
- Simple ranking in terface:
calculate_rating(self)
update_wins(self, wins: int)
update_losses(self, losses: int)
get_rank_info(self)
T ournamen tCard.p y
- Enhance d card class:
Inherits from Card, Com batable, and Rankable
Implemen ts all abstract metho ds from all three in terfac es
T rac ks tournamen t p erformance (wins, losses, rating)
Pro cesses tournamen t matc hes with rank ing up dates
T ournamen tPlatform.p y
- Platform managemen t system:
register_card(card: TournamentCard)
create_match(card1_id: str, card2_id: str)
get_leaderboard()
generate_tournament_report()
$> python3 -m ex4.main
=== DataDeck Tournament Platfo rm ===
Registering Tourna ment C ards...
Fire Dragon (ID: dragon_001):
- Interfaces: [Card, Combatabl e, Ran kable]
Ice Wizard (ID: wizard_001):
Creating tournamen t matc h...
Match result: {
winner_rat ing
l oser_rating
Tournament Leaderb oard:
1. Fire Dragon - Rating: 1216 (1-0)
2. Ice Wizard - Rating: 1134 (0-1)
Platform Report:
total_car ds
matc hes_played
avg_rating
pla tform_status
=== Tournament Platform Succes sfully Deployed! ===
All abstract patterns working togeth er har moniously!
multiple inheritance
allow a class to implement several
interfaces? What are the benefits of combining ranking capabilities
with card game mechanics?
Chapter X
Submission
T urn in y our assignmen t in y our
rep ository as usual. Only the w ork inside y our rep os-
itory will b e ev aluated during the defense. Don't hesitate to double c hec k the names of
y our les to ensure they are correct.
During evaluation, you may be asked to explain abstract classes,
demonstrate polymorphism, or show how interfaces enable multiple
inheritance. Focus on understanding the concepts, not just the
implementation.
Keep card game logic simple - the focus is on demonstrating abstract
programming patterns. Each exercise builds on the previous one, so
make sure your imports work correctly.
Abstract programming patterns are the foundation of extensible
software design. You've learned how to create systems that can grow
and adapt to new card types and game mechanics!